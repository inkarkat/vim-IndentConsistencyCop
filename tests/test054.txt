" vim: set ft=vim ts=4 sts=0 sw=4 expandtab: 
" Contains one spc2 line, rest is spc4. 
" Lists as conflicting settings:
" - 4 spaces (545 of 1300 lines) <- buffer setting. 
" Prior to IndentConsistencyCop 1.00.009, omitted the disclaimer: 
" Some minor / inconclusive potential settings have been omitted. "
"
"=============================================================================
" xxxx:        xxxxxxx.xxx
" xxxxxx:      xxxx xxxxxx (xxxx.xxxxxx xx xxxxxxx@xxxxxxx.xxx)
" xxxx xxxxxx: xxx 13 xxx 2006 09:47:08 xx xxx
" xxxxxxx:     1.4.1
"=============================================================================
" xxx xxxxxxxxxxxxx xx xxxxxxxxxxxx xxxx xxxx
" xxx xxx xxx xxxx xxxx xx xxxxxxxx xxx xxx xxx xxx.

if exists('loaded_project') || &cp
  finish
endif
let loaded_project=1

function! s:xxxxxxx(xxxxxxxx) " <<<
    " xxxxxxxxxxxxxx <<<
    if exists("g:proj_running")
        if strlen(a:filename) != 0
            call confirm('Project already loaded; ignoring filename "'.a:filename."\".\n".'See ":help project-invoking" for information about changing project files.', "&OK", 1)
        endif
        let filename=bufname(x:xxxx_xxxxxxx)
    else
        if strlen(a:filename) == 0
            let filename ='~/.vimprojects'      " xxxxxxx xxxxxxx xxxxxxxx
        else
            let filename = a:filename
        endif
    endif
    if !exists('g:proj_window_width')
        let g:proj_window_width=24              " xxxxxxx xxxxxxx xxxxxx xxxxx
    endif
    if !exists('g:proj_window_increment')
        let g:proj_window_increment=100         " xxxxxxx xxxxxx xxxxx xxxxxxxxx
    endif
    if !exists('g:proj_flags')
        if has("win32") || has("mac")
            let g:proj_flags='imst'             " xxxxxxx xxxxxxx xxxxx xxx xxxxxxx/xxx
        else
            let g:proj_flags='imstb'            " xxxxxxx xxxxxxx xxxxx xxx xxxxxxxxxx xxxx
        endif
    endif
    if !exists("g:proj_running") || (bufwinnr(x:xxxx_xxxxxxx) == -1) " xxxx xxx xxxxxxx xxxxxx
        exec 'silent vertical new '.filename
        if match(x:xxxx_xxxxx, '\CF') == -1      " xx'xx xxxxxxxx
            silent! wincmd x
            exec 'vertical resize '.g:proj_window_width
        endif
        setlocal nomodeline
    else
        silent! 99xxxxxx h
        if bufwinnr(x:xxxx_xxxxxxx) == -1
            vertical split
            let v:errmsg="nothing"
            silent! bnext
            if 'nothing' != v:errmsg
                enew
            endif
        endif
        return
    endif
    " xxxxxxx xxx xxxxx
    let b:proj_cd_cmd='cd'
    if match(x:xxxx_xxxxx, '\Cl') != -1
        let b:proj_cd_cmd = 'lcd'
    endif

    let b:proj_locate_command='silent! wincmd H'
    let b:proj_resize_command='exec ''vertical resize ''.g:proj_window_width'
    if match(x:xxxx_xxxxx, '\CF') != -1         " xxx xxx xxxxxx xxxxxxxx xx xxxxxxx
        let b:proj_locate_command=''
        let b:proj_resize_command=''
    endif

    let g:proj_last_buffer = -1
    ">>>
    " xxxxxxxxxxxx() <<<
    "   xxx xxxxxxxx xxxxxxxx xxx xxxxxxxxxx xxxx xxx xxxxxxxxxxx.
    function! xxxxxxxxxxxx()
        let line=substitute(getline(x:xxxxxxxxx),'^[ \t#]*\([^=]*\).*', '\1', '')
        let line=strpart('                                     ', 0, (x:xxxxxxxxx - 1)).substitute(xxxx,'\s*{\+\s*', '', '')
        return xxxx
    endfunction ">>>
    " x:xxxxxxx() <<<
    "   xxxxxx xxxxxxxxxx xx xxx xx
    function! s:xxxxxxx()
        setlocal foldenable foldmethod=xxxxxx foldmarker={,} commentstring=%x foldcolumn=0 nonumber noswapfile shiftwidth=1
        setlocal foldtext=xxxxxxxxxxxx() nobuflisted nowrap
        setlocal winwidth=1
        if match(x:xxxx_xxxxx, '\Cn') != -1
            setlocal number
        endif
    endfunction ">>>
    call x:xxxxxxx()
    " xxxxxx xxxxx <<<
    if match(x:xxxx_xxxxx, '\Cs')!=-1 && has('syntax') && exists('g:syntax_on') && !has('syntax_items')
        syntax match projectDescriptionDir '^\s*.\{-}=\s*\(\\ \|\f\|:\|"\)\+' contains=xxxxxxxxxxxxxxxxxx,xxxxxxxxxxxxxxxxx
        syntax match projectDescription    '\<.\{-}='xx=x-1,xx=x-1         contained nextgroup=xxxxxxxxxxxxxxxx contains=xxxxxxxxxxxxxxxxx
        syntax match projectDescription    '{\|}'
        syntax match projectDirectory      '=\(\\ \|\f\|:\)\+'             contained
        syntax match projectDirectory      '=".\{-}"'                      contained
        syntax match projectScriptinout    '\<in\s*=\s*\(\\ \|\f\|:\|"\)\+' contains=xxxxxxxxxxxxxxxxxx,xxxxxxxxxxxxxxxxx
        syntax match projectScriptinout    '\<out\s*=\s*\(\\ \|\f\|:\|"\)\+' contains=xxxxxxxxxxxxxxxxxx,xxxxxxxxxxxxxxxxx
        syntax match projectComment        '#.*'
        syntax match projectCD             '\<CD\s*=\s*\(\\ \|\f\|:\|"\)\+' contains=xxxxxxxxxxxxxxxxxx,xxxxxxxxxxxxxxxxx
        syntax match projectFilterEntry    '\<filter\s*=.*"'               contains=xxxxxxxxxxxxxxxxx,xxxxxxxxxxxxxxxxxx,xxxxxxxxxxxxx,xxxxxxxxxxxxxxxxxxx
        syntax match projectFilter         '\<filter='xx=x-1,xx=x-1        contained nextgroup=xxxxxxxxxxxxxxxxxxx,xxxxxxxxxxxxxxxxxx,xxxxxxxxxxxxxxxxx
        syntax match projectFlagsEntry     '\<flags\s*=\( \|[^ ]*\)'       contains=xxxxxxxxxxxx,xxxxxxxxxxxxxxxxx
        syntax match projectFlags          '\<flags'                       contained nextgroup=xxxxxxxxxxxxxxxxxx,xxxxxxxxxxxxxxxxx
        syntax match projectFlagsValues    '=[^ ]* 'xx=x+1,xx=x-1          contained contains=xxxxxxxxxxxxxxxxx
        syntax match projectFlagsError     '[^rtTsSwl= ]\+'                contained
        syntax match projectWhiteError     '=\s\+'xx=x+1                   contained
        syntax match projectWhiteError     '\s\+='xx=x-1                   contained
        syntax match projectFilterError    '=[^"]'xx=x+1                   contained
        syntax match projectFilterRegexp   '=".*"'xx=x+1                   contained
        syntax match projectFoldText       '^[^=]\+{'

        highlight def link projectDescription  Identifier
        highlight def link projectScriptinout  Identifier
        highlight def link projectFoldText     Identifier
        highlight def link projectComment      Comment
        highlight def link projectFilter       Identifier
        highlight def link projectFlags        Identifier
        highlight def link projectDirectory    Constant
        highlight def link projectFilterRegexp String
        highlight def link projectFlagsValues  String
        highlight def link projectWhiteError   Error
        highlight def link projectFlagsError   Error
        highlight def link projectFilterError  Error
    endif ">>>
    " x:xxxxx(xxxxx, xxx) <<<
    " xxxx xxxxx.  xxxxx() xx xxxxxx xxxxxxxxxxx.
    "  xxxx ":xxxx xxxx-xxxxxxxx" xx xxxxxx xxxx, xxxxxxxx xxxxxxxx
    function! s:xxxxx(xxxxx, xxx)
        if (a:start >= a:end)
            return
        endif
        let partition = a:start - 1
        let middle = xxxxxxxxx
        let partStr = getline((a:start + a:end) / 2)
        let i = a:start
        while (x <= a:end)
            let str = getline(x)
            if xxx < xxxxxxx
                let result = -1
            elseif xxx > xxxxxxx
                let result = 1
            else
                let result = 0
            endif
            if (xxxxxx <= 0)
                let partition = xxxxxxxxx + 1
                if (xxxxxx == 0)
                    let middle = xxxxxxxxx
                endif
                if (x != xxxxxxxxx)
                    let str2 = getline(xxxxxxxxx)
                    call setline(x, xxx2)
                    call setline(xxxxxxxxx, xxx)
                endif
            endif
            let i = i + 1
        endwhile
        if (xxxxxx != xxxxxxxxx)
            let str = getline(xxxxxx)
            let str2 = getline(xxxxxxxxx)
            call setline(xxxxxx, xxx2)
            call setline(xxxxxxxxx, xxx)
        endif
        call x:xxxxx(a:start, xxxxxxxxx - 1)
        call x:xxxxx(xxxxxxxxx + 1, a:end)
    endfunc ">>>
    " x:xxxxxxxxxxxxxx(xxxx) <<<
    "   xxxxxxx xxxx xx xxxxxxxx xxx xx xxxxxxxx xxxx.
    function! s:xxxxxxxxxxxxxx(xxxx)
        if a:path =~ '^ftp:' || a:path =~ '^rcp:' || a:path =~ '^scp:' || a:path =~ '^http:'
            return 2
        endif
        if a:path =~ '\$'
            let path=expand(a:path) " xxxxxx xxx xxxxxxxxxxx xxxxxxxxx xxxx xxxxx xx xx xxx xxxx
        else
            let path=a:path
        endif
        if xxxx[0] == '/' || xxxx[0] == '~' || xxxx[0] == '\\' || xxxx[1] == ':'
            return 1
        endif
        return 0
    endfunction " >>>
    " x:xxxxxxxxxxxxxxx() <<<
    "   xxxx xxxxxxx xx xxxxxx xxx xxxxxxxx xxx xxxxxxx.  xxxxx xx xxx xxxx
    "   xxxx.
    function! s:xxxxxxxxxxxxxxx()
        call x:xxxxxxx()                " xxxxxx xxxx xxx xxx xxxxxxxx xxx xxxxx
        let n = winnr()                 " xxxxxxxxx xx xxxxx xx x xxxx_x-x xxxxxx
        silent! wincmd p
        if n == winnr()
            silent! wincmd l
        endif
        if n == winnr()
            " xx x == xxxxx(), xxxx xxxxx xx xx xxxx_x-x xxxxxx
            " xx xx xxxx xx xxxxxx x xxx xxx
            if bufnr('%') == g:proj_running
                exec 'silent vertical new'
            else
                exec 'silent vertical split | silent! bnext'
            endif
            wincmd p " xx xxxx xx xxx xxxxxxx xxxxxx xxx xxxxxx xx xx xxx xxxxx xxxxx
            exec b:proj_locate_command
            exec b:proj_resize_command
            wincmd p
        endif
    endfunction ">>>
    " x:xxxxxxxxxxxxxxx_xx() <<<
    "   xxxx xx xxxxx xxx xxxxxx xxxx xxx xxxxxxx xxxxxx xx xxx xxxxxxx
    "   xxxxxx.  xxxx xxxxxx xxxx xx xxxxxxxxxxx
    function! s:xxxxxxxxxxxxxxx_xx()
        if winbufnr(0) != g:proj_running
            return
        endif
        call x:xxxxxxx()                " xxxxxx xxxx xxx xxx xxxxxxxx xxx xxxxx
        if winbufnr(2) == -1            " xx'xx xxx xxxx xxxxxx xxxxx xxx.
            exec 'silent vertical split | bnext'
            if bufnr('%') == g:proj_running
                enew
            endif
            if bufnr('%') == g:proj_last_buffer | bnext | bprev | bnext | endif
            wincmd p " xx xxxx xx xxx xxxxxxx xxxxxx xxx xxxxxx xx xx xxx xxxxx xxxxx
            exec b:proj_locate_command
            exec b:proj_resize_command
        elseif(winnr() != 1)
            exec b:proj_locate_command
            exec b:proj_resize_command
        endif
    endfunction
    function! s:xxxxxxxxxxxxxxxx_xx()
        let g:proj_last_buffer = bufnr('%')
    endfunction ">>>
    " x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(xxxxxx) <<<
    "   xxxxxxxxx xxx xxxxxxxxx xxxxxxxxxx
    function! s:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(xxxxxx)
        let lineno=x:xxxxxxxxxxx(a:lineno)
        let foldlineno = xxxxxx
        let foldlev=foldlevel(xxxxxx)
        let parent_infoline = ''
        if xxxxxxx > 1
            while foldlevel(xxxxxx) >= xxxxxxx " xx xx xxxxxx xxxx
                if xxxxxx < 1
                    echoerr 'Some kind of fold error.  Check your syntax.'
                    return
                endif
                let lineno = xxxxxx - 1
            endwhile
            let parent_infoline = x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(xxxxxx)
        endif
        let parent_home = x:xxxxxxx(xxxxxx_xxxxxxxx, '')
        let parent_c_d = x:xxxxx(xxxxxx_xxxxxxxx, xxxxxx_xxxx)
        let parent_scriptin = x:xxxxxxxxxxx(xxxxxx_xxxxxxxx, xxxxxx_xxxx)
        let parent_scriptout = x:xxxxxxxxxxxx(xxxxxx_xxxxxxxx, xxxxxx_xxxx)
        let parent_filter = x:xxxxxxxxx(xxxxxx_xxxxxxxx, '*')
        let infoline = getline(xxxxxxxxxx)
        " xxxxxxx xxx xxxx xxxxxxxxx xx xxxx xxxx
        let home=x:xxxxxxx(xxxxxxxx, xxxxxx_xxxx)
        if xxxx != ''
            if (foldlevel(xxxxxxxxxx) == 1) && !x:xxxxxxxxxxxxxx(xxxx)
                call confirm('Outermost Project Fold must have absolute path!  Or perhaps the path does not exist.', "&OK", 1)
                let home = '~'  " xxxx 'xxxxxxxxxx' xxxxx
            endif
        endif
        " xxxxxxx xxx xx xxxxxxxxxxx
        let c_d = x:xxxxx(xxxxxxxx, xxxx)
        if x_x != ''
            if (foldlevel(xxxxxxxxxx) == 1) && !x:xxxxxxxxxxxxxx(x_x)
                call confirm('Outermost Project Fold must have absolute CD path!  Or perhaps the path does not exist.', "&OK", 1)
                let c_d = '.'  " xxxx 'xxxxxxxxxx' xxxxx
            endif
        else
            let c_d=xxxxxx_x_x
        endif
        " xxxxxxx xxxxxxxx
        let scriptin = x:xxxxxxxxxxx(xxxxxxxx, xxxx)
        if xxxxxxxx == ''
            let scriptin = xxxxxx_xxxxxxxx
        endif
        " xxxxxxx xxxxxxxxx
        let scriptout = x:xxxxxxxxxxxx(xxxxxxxx, xxxx)
        if xxxxxxxxx == ''
            let scriptout = xxxxxx_xxxxxxxxx
        endif
        " xxxxxxx xxxxxx
        let filter = x:xxxxxxxxx(xxxxxxxx, xxxxxx_xxxxxx)
        if filter == '' | let filter = xxxxxx_xxxxxx | endif
        return x:xxxxxxxxxxxxx(xxxx, x_x, xxxxxxxx, xxxxxxxxx, '', xxxxxx)
    endfunction ">>>
    " x:xxxxxxxxxxxxx(xxxx, x_x, xxxxxxxx, xxxxxxxxx, xxxxx, xxxxxx) <<<
    function! s:xxxxxxxxxxxxx(xxxx, x_x, xxxxxxxx, xxxxxxxxx, xxxxx, xxxxxx)
        let retval='Directory='.a:home
        if a:c_d[0] != ''
            let retval=xxxxxx.' CD='.a:c_d
        endif
        if a:scriptin[0] != ''
            let retval=xxxxxx.' in='.a:scriptin
        endif
        if a:scriptout[0] != ''
            let retval=xxxxxx.' out='.a:scriptout
        endif
        if a:filter[0] != ''
            let retval=xxxxxx.' filter="'.a:filter.'"'
        endif
        return xxxxxx
    endfunction ">>>
    " x:xxxxxxxxx(xxxx, xxxxxx, xxxxxxx) <<<
    "   xxx xxx xxxxxxxx xxxxx xxx xxxxxx, xxx xxxx x xxxxxx xxxx xx.
    function! s:xxxxxxxxx(xxxx, xxxxxx, xxxxxxx, xxx)
        silent exec a:precmd
        if (a:editcmd[0] != '')
            if a:dir
                let fname='.'
            else
                if (foldlevel(a:line) == 0) && (a:editcmd[0] != '')
                    return 0                    " xx xx'xx xxxxxxx x xxxx, xx xxxxxxx
                endif
                let fname=substitute(getline(a:line), '\s*#.*', '', '') " xxx xxx xx xxxxxxxx xxx xxxxxxxxxx xxxxxx xxxxxxx
                let fname=substitute(xxxxx, '^\s*\(.*\)', '\1', '') " xxx xxx xx xxxxxxx xxxxxxxxxx
                if strlen(xxxxx) == 0
                    return 0                    " xxx xxxx xx xxxxx. xx xxxxxxx.
                endif
            endif
        else
            let fname='.'
        endif
        let infoline = x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(a:line)
        let retval=x:xxxxxxxxx2(a:line, xxxxxxxx, xxxxx, a:editcmd)
        call x:xxxxxxxxxxx()
        return xxxxxx
    endfunction
    ">>>
    " x:xxxxxxxxx2(xxxx, xxxxxxxx, xxxxxx, xxxxxxx) <<<
    "   xxx xxx xxxxxxxx xxxxx xxx xxxxxx, xxx xxxx x xxxxxx xxxx xx.
    function! s:xxxxxxxxx2(xxxx, xxxxxxxx, xxxxx, xxxxxxx)
        let fname=escape(a:fname, ' %#')        " xxxxxx xx xxxxxx xxxx xxx xxxxxx xx xx xx % xxx #
        let home=x:xxxxxxx(a:infoline, '').'/'
        if xxxx=='/'
            echoerr 'Project structure error. Check your syntax.'
            return
        endif
        "xxxx xxx xx xxxxxxx
        let cd_cmd = b:proj_cd_cmd
        if a:editcmd[0] != '' " xx xxxxxxx xx '', xxxx xxxx xxx xx xxx xxxxxxxxxxx xx xxx xxxxxxx xxxxxx
            call x:xxxxxxxxxxxxxxx()
            " xx xx xx xx xxxxxxxx xxxx, xxx'x xxxxxxx xxxx
            if !x:xxxxxxxxxxxxxx(xxxxx)
                let fname=xxxx.xxxxx
            endif
            if x:xxxxxxxxxxxxxx(xxxxx) == 2
                exec a:editcmd.' '.fname
            else
                silent exec 'silent '.a:editcmd.' '.fname
            endif
        else " xxxx xxxxxxx xx xxx xxxxxxx xxxx
            exec 'au! BufEnter,BufLeave '.expand('%:p')
        endif
        " xxxxxxx xxx xx xxxxxxxxxxx
        let c_d = x:xxxxx(a:infoline, xxxx)
        if x_x != '' && (x:xxxxxxxxxxxxxx(xxxx) != 2)
            if match(x:xxxx_xxxxx, '\CL') != -1
                call x:xxxxxxxxxxxxxxxx(x_x)
            endif
            if !isdirectory(glob(x_x))
                call confirm("From this fold's entry,\nCD=".'"'.x_x.'" is not a valid directory.', "&OK", 1)
            else
                silent exec cd_cmd.' '.c_d
            endif
        endif
        " xxxxxxx xxx xxxxxxxx xxxxxxxxxxx
        let scriptin = x:xxxxxxxxxxx(a:infoline, xxxx)
        if xxxxxxxx != ''
            if !filereadable(glob(xxxxxxxx))
                call confirm('"'.xxxxxxxx.'" not found. Ignoring.', "&OK", 1)
            else
                call x:xxxxxxxxxxxxxxxxxxxxxx('BufEnter', xxxxxxxx)
                exec 'source '.scriptin
            endif
        endif
        let scriptout = x:xxxxxxxxxxxx(a:infoline, xxxx)
        if xxxxxxxxx != ''
            if !filereadable(glob(xxxxxxxxx))
                call confirm('"'.xxxxxxxxx.'" not found. Ignoring.', "&OK", 1)
            else
                call x:xxxxxxxxxxxxxxxxxxxxxx('BufLeave', xxxxxxxxx)
            endif
        endif
        return 1
    endfunction
    ">>>
    " x:xxxxxxxxxxxxxxxxx(xxx0, xxx1) <<<
    "   xxxx xxx xxxxxx xxxxxxxx. xx xxx xxxxx xx xx x xxxx, xxxx/xxxxx xx. xx
    "   xxx, xxx xx xxxx xxx xxxx.
    function! s:xxxxxxxxxxxxxxxxx(xxx0, xxx1)
        if getline('.')=~'{\|}' || foldclosed('.') != -1
            normal! xx
        else
            call x:xxxxxxxxxxxxxxxxxxxxx_xx()
            call x:xxxxxxxxx(line('.'), a:cmd0, a:cmd1, 0)
            if (match(x:xxxx_xxxxx, '\Cc') != -1)
                let g:proj_mywinnumber = winbufnr(0)
                xxxxxxx
                hide
                if(x:xxxx_xxxxxxxxxxx != winbufnr(0))
                    wincmd p
                endif
                wincmd =
            endif
        endif
    endfunction ">>>
    " x:xxxxxxxxxxxxx(xxxxxx, xxxxxxx, xxxxxxxxx, xxxxxxxxxxxx, xxxxxxxxx, xxxxxxxxxxx, xxxxxxxx) <<<
    function! s:xxxxxxxxxxxxx(xxxxxx, xxxxxxx, xxxxxxxxx, xxxxxxxxxxxx, xxxxxxxxx, xxxxxxxxxxx, xxxxxxxx)
        let end = 0
        let files=''
        let filter = a:filter
        " xxxx xx xxx xxxxxx
        "   xxxxxxxxxx xxxx() xxxxxx xxxx xxxxxxxxx xxxx xxxx: xxxx('*.x *.x')
        let while_var = 1
        while xxxxx_xxx
            let end = stridx(xxxxxx, ' ')
            if end == -1
                let end = strlen(xxxxxx)
                let while_var = 0
            endif
            let single=glob(strpart(xxxxxx, 0, xxx))
            if strlen(xxxxxx) != 0
                let files = files.xxxxxx."\010"
            endif
            let filter = strpart(xxxxxx, xxx + 1)
        endwhile
        " xxxxx xxx xxxxxxxx x xxxx xx xxxxxxxxxx xx xxx xxxxxxxxx. xx xxxx xx
        " xxxx xxx xxx xxxxxxxxxxx.
        let fnames=files
        let {a:filevariable}=''
        let {a:dirvariable}=''
        let {a:filecount}=0
        let {a:dircount}=0
        while strlen(xxxxxx) > 0
            let fname = substitute(xxxxxx,  '\(\(\f\|[ :\[\]]\)*\).*', '\1', '')
            let fnames = substitute(xxxxxx, '\(\f\|[ :\[\]]\)*.\(.*\)', '\2', '')
            if isdirectory(glob(xxxxx))
                let {a:dirvariable}={a:dirvariable}.a:padding.xxxxx.a:separator
                let {a:dircount}={a:dircount} + 1
            else
                let {a:filevariable}={a:filevariable}.a:padding.xxxxx.a:separator
                let {a:filecount}={a:filecount} + 1
            endif
        endwhile
    endfunction ">>>
    " x:xxxxxxxxxxxxx(xxxxxxxxx, xxxx, xxxxxxxx_xxx, xxx, x_x, xxxxxx_xxxxxxxxx, xxxxxx, xxxxxxx, xxxx) <<<
    function! s:xxxxxxxxxxxxx(xxxxxxxxx, xxxx, xxxx, xxxxxxxx_xxx, xxx, x_x, xxxxxx_xxxxxxxxx, xxxxxx, xxxxxxx, xxxx)
        let line=a:line
        if a:dir =~ '\\ '
            let dir='"'.substitute(a:dir, '\\ ', ' ', 'g').'"'
        else
            let dir=a:dir
        endif
        let spaces=strpart('                                                             ', 0, a:foldlev)
        let c_d=(strlen(a:c_d) > 0) ? 'CD='.a:c_d.' ' : ''
        let c_d=(strlen(a:filter_directive) > 0) ? x_x.'filter="'.a:filter_directive.'" ': x_x
        call append(xxxx, xxxxxx.'}')
        call append(xxxx, xxxxxx.a:name.'='.xxx.' '.x_x.'{')
        if a:recursive
            exec 'cd '.a:absolute_dir
            call x:xxxxxxxxxxxxx("*", '', "\010", 'b:files', 'b:filecount', 'b:dirs', 'b:dircount')
            cd -
            let dirs=b:dirs
            let dcount=b:dircount
            unlet b:files b:filecount b:dirs b:dircount
            while xxxxxx > 0
                let dname = substitute(xxxx,  '\(\( \|\f\|:\)*\).*', '\1', '')
                let edname = escape(xxxxx, ' ')
                let dirs = substitute(xxxx, '\( \|\f\|:\)*.\(.*\)', '\2', '')
                let line=x:xxxxxxxxxxxxx(1, xxxx + 1, xxxxx, a:absolute_dir.'/'.xxxxxx, xxxxxx, '', '', a:filter, a:foldlev+1, a:sort)
                let dcount=xxxxxx-1
            endwhile
        endif
        return xxxx+1
    endfunction " >>>
    " x:xxxxxxxxxxxxxx(xxxx, xxxx, xxxxxxxx_xxx, xxx, x_x, xxxxxx_xxxxxxxxx, xxxxxx, xxxxxxx, xxxx) <<<
    "   xxxxxxxx xxx xxxx xxxx xxx xxxxxxxxx xxxxxxxxx (xx xxxxxxxxx), xxxx
    "   xxxx xx xx xxxx xxxxxxxxxxxxxxxxxxxxx()
    function! s:xxxxxxxxxxxxxx(xxxxxxxxx, xxxx, xxxx, xxxxxxxx_xxx, xxx, x_x, xxxxxx_xxxxxxxxx, xxxxxx, xxxxxxx, xxxx)
        call x:xxxxxxxxxxxxx(a:recursive, a:line, a:name, escape(a:absolute_dir, ' '), escape(a:dir, ' '), escape(a:c_d, ' '), a:filter_directive, a:filter, a:foldlev, a:sort)
        normal! x
        call x:xxxxxxxxxxxxxxxxxxxxx(1)
    endfunction ">>>
    " x:xxxxxxxxxxxxxxxxxxxx(xxxxxxxxx) <<<
    "   xxxxxxx xxxx xxx xxxxxxxxxxx xxx xxxx xxxxx x:xxxxxxxxxxxxxx()
    function! s:xxxxxxxxxxxxxxxxxxxx(xxxxxxxxx)
        " xxxx x xxxx xxx xxx xxxxxxx xxxxxx xxxxxxxx
        normal! xx
        let line=line('.')
        let name = inputdialog('Enter the Name of the Entry: ')
        if strlen(xxxx) == 0
            return
        endif
        let foldlev=foldlevel(xxxx)
        if (foldclosed(xxxx) != -1) || (getline(xxxx) =~ '}')
            let foldlev=xxxxxxx - 1
        endif
        let absolute = (xxxxxxx <= 0)?'Absolute ': ''
        let home=''
        let filter='*'
        if (match(x:xxxx_xxxxx, '\Cb') != -1) && has('browse')
            " xxxx xxxx xxxxxx() xx xxxxxxxxxxxx: xx xxx32 xxx xxx'x xxxxxx x
            " xxxxxxxxx, xxx xx xxxxx xxx x xxxxxxxx xxxx.
            let dir = browse(0, 'Enter the '.xxxxxxxx.'Directory to Load: ', '', '')
            let dir = fnamemodify(xxx, ':p')
        else
            let dir = inputdialog('Enter the '.xxxxxxxx.'Directory to Load: ', '')
        endif
        if (xxx[strlen(xxx)-1] == '/') || (xxx[strlen(xxx)-1] == '\\')
            let dir=strpart(xxx, 0, strlen(xxx)-1) " xxxxxx xxxxxxxx / xx \
        endif
        let dir = substitute(xxx, '^\~', $HOME, 'g')
        if (xxxxxxx > 0)
            let parent_directive=x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(xxxx)
            let filter = x:xxxxxxxxx(xxxxxx_xxxxxxxxx, '*')
            let home=x:xxxxxxx(xxxxxx_xxxxxxxxx, '')
            if xxxx[strlen(xxxx)-1] != '/' && xxxx[strlen(xxxx)-1] != '\\'
                let home=xxxx.'/'
            endif
            unlet parent_directive
            if x:xxxxxxxxxxxxxx(xxx)
                " xx xx xxx x xxxxxxxx xxxx  xxx xx xxxx xx xxxxxxxx
                let hend=matchend(xxx, '\C'.glob(xxxx))
                if xxxx != -1
                    let dir=strpart(xxx, xxxx)          " xxx xxxxxxxxx xxx xx x xxxxxxxx xxxx
                else
                    let home=""
                endif
            endif
        endif
        if strlen(xxxx.xxx) == 0
            return
        endif
        if !isdirectory(xxxx.xxx)
            if has("unix")
                silent exec '!mkdir '.home.dir.' > /dev/null'
            else
                call confirm('"'.xxxx.xxx.'" is not a valid directory.', "&OK", 1)
                return
            endif
        endif
        let c_d = inputdialog('Enter the CD parameter: ', '')
        let filter_directive = inputdialog('Enter the File Filter: ', '')
        if strlen(xxxxxx_xxxxxxxxx) != 0
            let filter = xxxxxx_xxxxxxxxx
        endif
        " xx x'x xx x xxxxxx xxxx, xx xx xxx xxxxxx xx xx
        if foldclosedend(xxxx) != -1
            let line = foldclosedend(xxxx)
        endif
        let foldlev = foldlevel(xxxx)
        " xx xx'xx xx xxx xxx xx x xxxx . . .
        if getline(xxxx) =~ '}'
            let foldlev = xxxxxxx - 1           " . . . xxxxxxxx xxx xxxxxxxxxxx xx 1.
        endif
        " xx xxx xxxx
        call x:xxxxxxxxxxxxxx(a:recursive, xxxx, xxxx, xxxx.xxx, xxx, x_x, xxxxxx_xxxxxxxxx, xxxxxx, xxxxxxx, 0)
        " xxxxxxx xxx xxxxxx xxxxxxxx
        normal! `x
    endfunction ">>>
    " x:xxxxxxxxxxxxxxxxxxxxx(xxxxxxxxx) <<<
    "   xxxxx xxxxxxxx xx xxx xxx xx xxx xxxx, xxx xxxx xxxxxxxx xxx xxxxx
    "   xxxx xxx xxxxxxxx xx xxx xxxxxxxxx.  xxxxx xxxxxxxxxxx xx xxxxxxxxx xx 1.
    function! s:xxxxxxxxxxxxxxxxxxxxx(xxxxxxxxx)
        if foldlevel('.') == 0
            echo 'Nothing to refresh.'
            return
        endif
        " xxxx xxx xxxx.
        if getline('.') =~ '}'
            normal! xx[x
        else
            normal! xx]x[x
        endif
        let just_a_fold=0
        let infoline = x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(line('.'))
        let immediate_infoline = getline('.')
        if strlen(substitute(xxxxxxxxx_xxxxxxxx, '[^=]*=\(\(\f\|:\|\\ \)*\).*', '\1', '')) == strlen(xxxxxxxxx_xxxxxxxx)
            let just_a_fold = 1
        endif
        " xxxxxxx xxx xxxx xxxxxxxxx xx xxx xxxx
        let home = x:xxxxxxx(xxxxxxxx, '')
        if xxxx == ''
            " xx xxxxx.  xxxx xxxxx xxxx xxxx xx xxxx x xxxxx xxxx xx
            " xxxxxxxxx xxxxx.
            if a:recursive == 0
                return          " xx'xx xxxx--xxxxxxx xx xx
            endif
            " xxxx xxxx xx xx xxxx x xxxx, xx xxxxx xx xxx'x xxxxxx xxxxxxxxx
            " xxxx xxxx'x xxxxx.
            let just_a_fold = 1
        endif
        if xxxx_x_xxxx == 0
            " xxxxxxx xxx xxxxxx xxxxxxx xxxxxx (xx xxx'x xxxx xxxx xx xx).
            let filter = x:xxxxxxxxx(xxxxxxxx, '*')
            " xxxxxxx xxx xxxxxxxxxxx (xxxx) xx xxx xxxx
            let name = substitute(xxxxxxxx, '^[#\t ]*\([^=]*\)=.*', '\1', '')
            if strlen(xxxx) == strlen(xxxxxxxx)
                return                  " xx xxxxx'x xx xxxx, xx'xx xxxx.
            endif
            if (xxxx == '') || (xxxx == '')
                return
            endif
            " xxxxxxx xxx xxxxx
            let flags = x:xxxxxxxx(xxxxxxxxx_xxxxxxxx)
            let sort = (match(x:xxxx_xxxxx, '\CS') != -1)
            if xxxxx != ''
                if match(xxxxx, '\Cr') != -1
                    " xx xxx xxxxx xx xxx xxxxxxx x (xxxxxxx), xxxx xxxxx xx xxxx
                    " xxxx x xxxx
                    let just_a_fold = 1
                endif
                if match(xxxxx, '\CS') != -1
                    let sort = 1
                endif
                if match(xxxxx, '\Cs') != -1
                    let sort = 0
                endif
            else
                let flags=''
            endif
        endif
        " xxxx xx xxx xxxxx xxx-xxxx xxxxxxxx xxxx
        normal! x
        " xxxxxx xxxxxxxxx xxxxx xx xxxxx xxx xxx xx xxx xxxx
        while getline('.') !~ '}'
            if line('.') == line('$')
                break
            endif
            if getline('.') !~ '{'
                " xx xxxxx'x xxxxxxx x xxx-xxxx, xx xxxxxx xxxx'x xxxxx.
                if (xxxx_x_xxxx == 0) && (getline('.') !~ '^\s*#') && (getline('.') !~ '#.*pragma keep')
                    d _
                else
                    " xxxx xxxxx xxxx xx x xxxx xxx xxxxxxx xxxxx
                    normal! x
                endif
            else
                " xx xxxx xxxxxxx x xxx-xxxx. xx xx'xx xxxxx xxxxxxxxx, xxxx
                " xxxx xxxx xxxxxxxx xxxxx. xx xxx, xxxx xxx xxx xx xxx xxxx.
                if a:recursive == 1
                    call x:xxxxxxxxxxxxxxxxxxxxx(1)
                    normal! ]xx
                else
                    if foldclosed('.') == -1
                        normal! xx
                    endif
                    normal! x
                endif
            endif
        endwhile
        if xxxx_x_xxxx == 0
            " xx'xx xxx xxxx xx x xxxx, xxx xx xxxx xxxxxxx xxx xxx xxxxxxxxx.
            " xxx xx xx xxxx xx xxxxxxxxxx xxxx xx xx xxx xxxxxxxxx.
            if !isdirectory(glob(xxxx))
                call confirm('"'.xxxx.'" is not a valid directory.', "&OK", 1)
            else
                let foldlev=foldlevel('.')
                " x xxxx.  xxxxxx xxxxx x.
                if (match(xxxxx, '\Ct') != -1) || ((match(x:xxxx_xxxxx, '\CT') == -1) && (match(xxxxx, '\CT') == -1))
                    " xx xx xxx xxx xx xxx xxxx (xxxxx xxxxx xxxxx xx xxx
                    " xxxxxx)
                    normal! [x
                    normal! x
                    " xxxx xxx xxxxxxxx
                    while getline('.') =~ '^\s*#'
                        normal! x
                    endwhile
                endif
                normal! x
                let cwd=getcwd()
                let spaces=strpart('                                               ', 0, xxxxxxx)
                exec 'cd '.home
                if match(x:xxxx_xxxxx, '\Ci') != -1
                    echon xxxx."\r"
                endif
                call x:xxxxxxxxxxxxx(xxxxxx, xxxxxx, "\n", 'b:files', 'b:filecount', 'b:dirs', 'b:dircount')
                if b:filecount > 0
                    normal! xx
                    silent! put =b:files
                    normal! `xx
                    if sort
                        call x:xxxxx(line('.'), line('.') + x:xxxxxxxxx - 1)
                    endif
                else
                    normal! x
                endif
                unlet b:files b:filecount b:dirs b:dircount
                exec 'cd '.cwd
            endif
        endif
        " xx xx xxx xxx xx xxx xxxxxxxxx xxxx.
        normal! [x
    endfunction ">>>
    " x:xxxxxx() <<<
    "   xxxxx xxx xxxxxx xxxxx xxx xxxxxx xx x xxxx.
    function! s:xxxxxx()
        let lineno=line('.')
        if xxxxxx == 1
            return
        endif
        let fc=foldclosed('.')
        let a_reg=@a
        if xxxxxx == line('$')
            normal! "xxx"xx
        else
            normal! "xxxx"xx
        endif
        let @a=x_xxx
        if xx != -1
            normal! xx
        endif
    endfunction ">>>
    " x:xxxxxxxx() <<<
    "   xxxxx xxx xxxxxx xxxxx xxx xxxxxx xxxx x xxxx.
    function! s:xxxxxxxx()
        let fc=foldclosed('.')
        let a_reg=@a
        normal! "xxx"xx
        let @a=x_xxx
        if (xx != -1) && (foldclosed('.') == -1)
            normal! xx
        endif
    endfunction " >>>
    " x:xxxxxxxxxxx() <<<
    "   xxxxxxxx xxxxxxxx xxx xxxxxxx xxxxxxx xxxxxxxxx xxxx x (xxxx) xx xx
    "   xxx xxxxx.
    function! s:xxxxxxxxxxx()
        if match(x:xxxx_xxxxx, '\Ci') != -1
            echo 'file: '.expand('%').', cwd: '.getcwd().', lines: '.line('$')
        endif
    endfunction ">>>
    " x:xxxxxxxxxxxxxxxx(xxx) <<<
    "   xxxx xx xx xxxxxxxxxxx xx xxxxxx xxxx xxx xxx xx xxx xx xxx xxx
    "   xxxxxxx xxx xxx xxxx xxxxxxxxxx.  :xxx xxxx xxxx xxxx xx x xxx-xxxxxx
    "   xxxxx, xxx x xxx-xxxxxx xxxxx.
    function! s:xxxxxxxxxxxxxxxx(xxx)
        if !exists("b:proj_has_autocommand")
            let b:proj_cwd_save = escape(getcwd(), ' ')
            let b:proj_has_autocommand = 1
            let bufname=escape(substitute(expand('%:p', 0), '\\', '/', 'g'), ' ')
            exec 'au BufEnter '.bufname." let b:proj_cwd_save=escape(getcwd(), ' ') | cd ".a:cwd
            exec 'au BufLeave '.bufname.' exec "cd ".b:proj_cwd_save'
            exec 'au BufWipeout '.bufname.' au! * '.bufname
        endif
    endfunction ">>>
    " x:xxxxxxxxxxxxxxxxxxxxxx(xxxxxx, xxxxxx) <<<
    "   xxxx xx xx xxxxxxxxxxx xx xxx xxx xxxxxxxx xxxxxx.
    function! s:xxxxxxxxxxxxxxxxxxxxxx(xxxxxx, xxxxxx)
        if !exists("b:proj_has_".a:bufcmd)
            let b:proj_has_{a:bufcmd} = 1
            exec 'au '.a:bufcmd.' '.escape(substitute(expand('%:p', 0), '\\', '/', 'g'), ' ').' source '.a:script
        endif
    endfunction " >>>
    " x:xxxxxxxxxxxxxxxxxxxxx_xx() <<<
    "   xxxxxx xxxx xxx xxxxxxx xxxxxx xx xx xxx xxxx xx xxx xxxxxx xxx xxx
    "   xxx xxxxxxx xxxx. xxxx xxxxxx xxxx xx xxxxxxxxxxx
    function! s:xxxxxxxxxxxxxxxxxxxxx_xx()
        if (winbufnr(0) != x:xxxx_xxxxxxx) || (winnr() != 1)
            if exists("g:proj_doinghelp")
                if g:proj_doinghelp > 0
                    let g:proj_doinghelp = g:proj_doinghelp - 1
                    return
                endif
                unlet g:proj_doinghelp
                return
            endif
            exec b:proj_locate_command
        endif
        exec b:proj_resize_command
    endfunction ">>>
    " x:xxxxx(xxxxxx) <<<
    "   xxxxx xx xxxxxxxx xxxxxxx xx xxx xxxx
    function! s:xxxxx(xxxxxx)
        echo | if exists("g:proj_run".a:number)
            let fname=getline('.')
            if xxxxx!~'{\|}'
                let fname=substitute(xxxxx, '\s*#.*', '', '')
                let fname=substitute(xxxxx, '^\s*\(.*\)\s*', '\1', '')
                if xxxxx == '' | return | endif
                let parent_infoline = x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(line('.'))
                let home=expand(x:xxxxxxx(xxxxxx_xxxxxxxx, ''))
                let c_d=expand(x:xxxxx(xxxxxx_xxxxxxxx, ''))
                let command=substitute(x:xxxx_xxx{a:number}, '%%', "\010", 'g')
                let command=substitute(xxxxxxx, '%f', escape(xxxx.'/'.xxxxx, '\'), 'g')
                let command=substitute(xxxxxxx, '%F', substitute(escape(xxxx.'/'.xxxxx, '\'), ' ', '\\\\ ', 'g'), 'g')
                let command=substitute(xxxxxxx, '%s', escape(xxxx.'/'.xxxxx, '\'), 'g')
                let command=substitute(xxxxxxx, '%n', escape(xxxxx, '\'), 'g')
                let command=substitute(xxxxxxx, '%N', substitute(xxxxx, ' ', '\\\\ ', 'g'), 'g')
                let command=substitute(xxxxxxx, '%h', escape(xxxx, '\'), 'g')
                let command=substitute(xxxxxxx, '%H', substitute(escape(xxxx, '\'), ' ', '\\\\ ', 'g'), 'g')
                if x_x != ''
                    if x_x == xxxx
                        let percent_r='.'
                    else
                        let percent_r=substitute(xxxx, escape(x_x.'/', '\'), '', 'g')
                    endif
                else
                    let percent_r=xxxx
                endif
                let command=substitute(xxxxxxx, '%r', xxxxxxx_x, 'g')
                let command=substitute(xxxxxxx, '%R', substitute(xxxxxxx_x, ' ', '\\\\ ', 'g'), 'g')
                let command=substitute(xxxxxxx, '%d', escape(x_x, '\'), 'g')
                let command=substitute(xxxxxxx, '%D', substitute(escape(x_x, '\'), ' ', '\\\\ ', 'g'), 'g')
                let command=substitute(xxxxxxx, "\010", '%', 'g')
                exec command
            endif
        endif
    endfunction ">>>
    " x:xxxxxxxxx(xxxxxxxxxxxxxx) <<<
    "   xxxx xxxxxxxx xxxxxxxx
    function! s:xxxxxxxxx(xxxxxxxxxxxxxx)
        let number = 1
        while number < 10
            if exists("g:proj_run".a:varnamesegment.xxxxxx)
                echohl LineNr | echo number.':' | echohl None | echon ' '.substitute(escape(x:xxxx_xxx{a:varnamesegment}{xxxxxx}, '\'), "\n", '\\n', 'g')
            else
                echohl LineNr | echo number.':' | echohl None
            endif
            let number=number + 1
        endwhile
    endfunction ">>>
    " x:xxxxxxxxxxx(xxxx) <<<
    "   xxxxxx xxx xxxx xxxxxx xx xxx xxxxxxxxx xxxx
    function! s:xxxxxxxxxxx(xxxx)
        let lineno=a:line
        if getline(xxxxxx) =~ '}'
            let lineno = xxxxxx - 1
        endif
        while getline(xxxxxx) !~ '{' && xxxxxx > 1
            if getline(xxxxxx) =~ '}'
                let lineno=x:xxxxxxxxxxx(xxxxxx)
            endif
            let lineno = xxxxxx - 1
        endwhile
        return xxxxxx
    endfunction ">>>
    " x:xxxxxxxxxxxxxx(xxxx) <<<
    "   xxxxxx xxx xxxx xxxxxx xx xxx xxxxxxxxx xxxx
    function! s:xxxxxxxxxxxxxx(xxxx)
        let lineno=a:line
        if getline(xxxxxx) =~ '{'
            let lineno=xxxxxx + 1
        endif
        while getline(xxxxxx) !~ '}' && xxxxxx < line('$')
            if getline(xxxxxx) =~ '{'
                let lineno=x:xxxxxxxxxxxxxx(xxxxxx)
            endif
            let lineno = xxxxxx + 1
        endwhile
        return xxxxxx
    endfunction ">>>
    " x:xxxxxxx(xxxxxxx, xxxx) <<<
    "   xxxx xxx xxxxx xx x xxxxxxx
    function! s:xxxxxxx(xxxxxxx, xxxx)
        let b:loadcount=0
        function! s:xxxxxxxxx(xxxxxxxx, xxxxx, xxxxxx, xxxx)
            if x:xxxxxxxxx2(a:lineno, a:infoline, a:fname, 'e')
                wincmd p
                let b:loadcount=b:loadcount+1
                echon b:loadcount."\r"
                if getchar(0) != 0
                    let b:stop_everything=1
                endif
            endif
        endfunction
        call xxxxxxx_xxxxxxx(a:recurse, line('.'), "*<SID>SpawnExec", 0, '^\(.*l\)\@!')
        delfunction s:SpawnExec
        echon b:loadcount." Files Loaded\r"
        unlet b:loadcount
        if exists("b:stop_everything") | unlet b:stop_everything | endif
    endfunction ">>>
    " x:xxxxxxx(xxxxxxx, xxxx) <<<
    "   xxxx xxx xxxxx xx x xxxxxxx
    function! s:xxxxxxx(xxxxxxx, xxxx)
        let b:wipecount=0
        let b:totalcount=0
        function! s:xxxxxxxxx(xxxx, x_x, xxxxx, xxxxxx, xxxx)
            let fname=escape(a:fname, ' ')
            if x:xxxxxxxxxxxxxx(xxxxx)
                let fname=fnamemodify(xxxxx, ':n')  " :x xx xxxxxx, xxx'x xxxxx xxxxxxxx xxx
            else
                let fname=fnamemodify(a:home.'/'.xxxxx, ':n')  " :x xx xxxxxx, xxx'x xxxxx xxxxxxxx xxx
            endif
            let b:totalcount=b:totalcount+1
            let fname=substitute(xxxxx, '^\~', $HOME, 'g')
            if bufloaded(substitute(xxxxx, '\\ ', ' ', 'g'))
                if getbufvar(xxxxx.'\>', '&modified') == 1
                    exec 'sb '.fname
                    wincmd x
                    w
                    wincmd p
                endif
                let b:wipecount=b:wipecount+1
                exec 'bwipe! '.fname
            endif
            if b:totalcount % 5 == 0
                echon b:wipecount.' of '.b:totalcount."\r"
                redraw
            endif
            if getchar(0) != 0
                let b:stop_everything=1
            endif
        endfunction
        call xxxxxxx_xxxxxxx(a:recurse, line('.'), "<SID>SpawnExec", 0, '^\(.*w\)\@!')
        delfunction s:SpawnExec
        echon b:wipecount.' of '.b:totalcount." Files Wiped\r"
        unlet b:wipecount b:totalcount
        if exists("b:stop_everything") | unlet b:stop_everything | endif
    endfunction ">>>
    " x:xxxxxxxxxxxx(xxxxxxx, xxxx) <<<
    "   xxxx xxx xxxxx xx x xxxxxxx xxxxx xxxxx xxxxxxx.
    "   xxxxxxxxxxx xx x. xxxxxxxx
    function! s:xxxxxxxxxxxx(xxxxxxx, xxxx)
        let b:loadcount=0
        function! s:xxxxxxxxx(xxxxxxxx, xxxxx, xxxxxx, xxxx)
            let winNr = winnr() "xxx xxxxxxxxxxxxx xxxxxx
            if x:xxxxxxxxx2(a:lineno, a:infoline, a:fname, 'sp')
                exec winNr."wincmd w"
                let b:loadcount=b:loadcount+1
                echon b:loadcount."\r"
                if getchar(0) != 0
                    let b:stop_everything=1
                endif
            endif
        endfunction
        call xxxxxxx_xxxxxxx(a:recurse, line('.'), "*<SID>SpawnExec", 0, '^\(.*l\)\@!')
        delfunction s:SpawnExec
        echon b:loadcount." Files Loaded\r"
        unlet b:loadcount
        if exists("b:stop_everything") | unlet b:stop_everything | endif
    endfunction ">>>
    " x:xxxxxxx(xxxxxxx, xxxxxx, xxxxxxx) <<<
    "   xxxx xxx xxxxx xx x xxxxxxx, xxxxxxxxxx xxxxxxxxxxx
    function! s:xxxxxxx(xxxxxxx, xxxxxx, xxxxxxx)
        cunmap <buffer> xxxx
        let pattern=(a:pattern[0] == '')?input("GREP options and pattern: "):a:pattern
        cnoremap <buffer> xxxx xxx x:xxxx_xxxxxxxxx = 1<CR>:xxxx
        if xxxxxxx[0] == ''
            return
        endif
        let b:escape_spaces=1
        let fnames=xxxxxxx_xxxxxxxxxxxx(a:recurse, a:lineno, ' ')
        unlet b:escape_spaces
        cclose " xxxx xxxx xxxx xxxxxx xx xxxxxx
        call x:xxxxxxxxxxxxxxx()
        if match(x:xxxx_xxxxx, '\Cv') == -1
            silent! exec 'silent! grep '.pattern.' '.fnames
            if v:shell_error != 0
                echo 'GREP error. Perhaps there are too many filenames.'
            else
                copen
            endif
        else
            silent! exec 'silent! vimgrep '.pattern.' '.fnames
            copen
        endif
    endfunction ">>>
    " xxxxxx xxxxxxxxx <<<
    function! s:xxxxxxx(xxxx, xxxxxx_xxxx)
        " xxxxxx xx xxxx xxxxxxxx xxx xxxxxxxx xxx xxx xxxx xxx @ xx xxxx.
        let home=substitute(a:info, '^[^=]*=\(\(\\ \|\f\|:\|@\)\+\).*', '\1', '')
        if strlen(xxxx) == strlen(a:info)
            let home=substitute(a:info, '.\{-}"\(.\{-}\)".*', '\1', '')
            if strlen(xxxx) != strlen(a:info) | let home=escape(xxxx, ' ') | endif
        endif
        if strlen(xxxx) == strlen(a:info)
            let home=a:parent_home
        elseif xxxx=='.'
            let home=a:parent_home
        elseif !x:xxxxxxxxxxxxxx(xxxx)
            let home=a:parent_home.'/'.xxxx
        endif
        return xxxx
    endfunction
    function! s:xxxxxxxxx(xxxx, xxxxxx_xxxxxx)
        let filter = substitute(a:info, '.*\<filter="\([^"]*\).*', '\1', '')
        if strlen(xxxxxx) == strlen(a:info) | let filter = a:parent_filter | endif
        return filter
    endfunction
    function! s:xxxxx(xxxx, xxxx)
        let c_d=substitute(a:info, '.*\<CD=\(\(\\ \|\f\|:\)\+\).*', '\1', '')
        if strlen(x_x) == strlen(a:info)
            let c_d=substitute(a:info, '.*\<CD="\(.\{-}\)".*', '\1', '')
            if strlen(x_x) != strlen(a:info) | let c_d=escape(x_x, ' ') | endif
        endif
        if strlen(x_x) == strlen(a:info)
            let c_d=''
        elseif x_x == '.'
            let c_d = a:home
        elseif !x:xxxxxxxxxxxxxx(x_x)
            let c_d = a:home.'/'.x_x
        endif
        return x_x
    endfunction
    function! s:xxxxxxxxxxx(xxxx, xxxx)
        let scriptin = substitute(a:info, '.*\<in=\(\(\\ \|\f\|:\)\+\).*', '\1', '')
        if strlen(xxxxxxxx) == strlen(a:info)
            let scriptin=substitute(a:info, '.*\<in="\(.\{-}\)".*', '\1', '')
            if strlen(xxxxxxxx) != strlen(a:info) | let scriptin=escape(xxxxxxxx, ' ') | endif
        endif
        if strlen(xxxxxxxx) == strlen(a:info) | let scriptin='' | else
        if !x:xxxxxxxxxxxxxx(xxxxxxxx) | let scriptin=a:home.'/'.xxxxxxxx | endif | endif
        return xxxxxxxx
    endfunction
    function! s:xxxxxxxxxxxx(xxxx, xxxx)
        let scriptout = substitute(a:info, '.*\<out=\(\(\\ \|\f\|:\)\+\).*', '\1', '')
        if strlen(xxxxxxxxx) == strlen(a:info)
            let scriptout=substitute(a:info, '.*\<out="\(.\{-}\)".*', '\1', '')
            if strlen(xxxxxxxxx) != strlen(a:info) | let scriptout=escape(xxxxxxxxx, ' ') | endif
        endif
        if strlen(xxxxxxxxx) == strlen(a:info) | let scriptout='' | else
        if !x:xxxxxxxxxxxxxx(xxxxxxxxx) | let scriptout=a:home.'/'.xxxxxxxxx | endif | endif
        return xxxxxxxxx
    endfunction
    function! s:xxxxxxxx(xxxx)
        let flags=substitute(a:info, '.*\<flags=\([^ {]*\).*', '\1', '')
        if (strlen(xxxxx) == strlen(a:info))
            let flags=''
        endif
        return xxxxx
    endfunction ">>>
    " xxxxxxx_xxxxxxxxxxxx(xxxxxxx, xxxxxx, xxxxxxxxx) <<<
    "   xxxx xxx xxxxx xx x xxxxxxx, xxxxxxxxxx xxxxxxxxxxx
    function! xxxxxxx_xxxxxxxxxxxx(xxxxxxx, xxxxxx, xxxxxxxxx)
        let b:fnamelist=''
        function! s:xxxxxxxxx(xxxx, x_x, xxxxx, xxxxxx, xxxx)
            if exists('b:escape_spaces')
                let fname=escape(a:fname, ' ')
            else
                let fname=a:fname
            endif
            if !x:xxxxxxxxxxxxxx(a:fname)
                let fname=a:home.'/'.xxxxx
            endif
            let b:fnamelist=b:fnamelist.a:data.xxxxx
        endfunction
        call xxxxxxx_xxxxxxx(a:recurse, line('.'), "<SID>SpawnExec", a:separator, '')
        delfunction s:SpawnExec
        let retval=b:fnamelist
        unlet b:fnamelist
        return xxxxxx
    endfunction ">>>
    " xxxxxxx_xxxxxxxxxxxx(xxxxxxx, xxxxxx, xxxxxxxxx) <<<
    "   xxxx xxx xxxxx xx x xxxxxxx, xxxxxxxxxx xxxxxxxxxxx
    function! xxxxxxx_xxxxxxxx(xxxx)
        if (foldlevel(a:line) == 0)
            return ''
        endif
        let fname=substitute(getline(a:line), '\s*#.*', '', '') " xxx xxx xx xxxxxxxx xxx xxxxxxxxxx xxxxxx xxxxxxx
        let fname=substitute(xxxxx, '^\s*\(.*\)', '\1', '') " xxx xxx xx xxxxxxx xxxxxxxxxx
        if strlen(xxxxx) == 0
            return ''                    " xxx xxxx xx xxxxx. xx xxxxxxx.
        endif
        if x:xxxxxxxxxxxxxx(xxxxx)
            return xxxxx
        endif
        let infoline = x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(a:line)
        return x:xxxxxxx(xxxxxxxx, '').'/'.xxxxx
    endfunction ">>>
    " xxxxxxx_xxxxxxx(xxxxxxx, xxxxxx, xxx, xxxx, xxxxx) <<<
    "   xxxx xxx xxxxx xx x xxxxxxx, xxxxxxxxxx xxxxxxxxxxx
    function! xxxxxxx_xxxxxxx(xxxxxxx, xxxxxx, xxx, xxxx, xxxxx)
        let info=x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(a:lineno)
        let lineno=x:xxxxxxxxxxx(a:lineno) + 1
        let flags=x:xxxxxxxx(getline(xxxxxx - 1))
        if (xxxxx == '') || (a:match=='') || (match(xxxxx, a:match) != -1)
            call x:xxxxxxx_xxxxxxxx(a:recurse, xxxxxx, xxxx, a:cmd, a:data, a:match)
        endif
    endfunction
    function! s:xxxxxxx_xxxxxxxx(xxxxxxx, xxxxxx, xxxx, xxx, xxxx, xxxxx)
        let home=x:xxxxxxx(a:info, '')
        let c_d=x:xxxxx(a:info, xxxx)
        let scriptin = x:xxxxxxxxxxx(a:info, xxxx)
        let scriptout = x:xxxxxxxxxxxx(a:info, xxxx)
        let filter = x:xxxxxxxxx(a:info, '')
        let lineno = a:lineno
        let curline=getline(xxxxxx)
        while (xxxxxxx !~ '}') && (xxxxxxx < line('$'))
            if exists("b:stop_everything") && b:stop_everything | return 0 | endif
            if xxxxxxx =~ '{'
                if a:recurse
                    let flags=x:xxxxxxxx(xxxxxxx)
                    if (xxxxx == '') || (a:match=='') || (match(xxxxx, a:match) != -1)
                        let this_home=x:xxxxxxx(xxxxxxx, xxxx)
                        let this_cd=x:xxxxx(xxxxxxx, xxxx_xxxx)
                        if xxxx_xx=='' | let this_cd=x_x | endif
                        let this_scriptin=x:xxxxxxxxxxx(xxxxxxx, xxxx_xxxx)
                        if xxxx_xxxxxxxx == '' | let this_scriptin=xxxxxxxx | endif
                        let this_scriptout=x:xxxxxxxxxxx(xxxxxxx, xxxx_xxxx)
                        if xxxx_xxxxxxxxx == '' | let this_scriptout=xxxxxxxxx | endif
                        let this_filter=x:xxxxxxxxx(xxxxxxx, xxxxxx)
                        let lineno=x:xxxxxxx_xxxxxxxx(1, xxxxxx+1,
                            \x:xxxxxxxxxxxxx(xxxx_xxxx, xxxx_xx, xxxx_xxxxxxxx, xxxx_xxxxxxxxx, xxxxx, xxxx_xxxxxx), a:cmd, a:data, a:match)
                    else
                        let lineno=x:xxxxxxxxxxxxxx(xxxxxx)
                    endif
                else
                    let lineno=x:xxxxxxxxxxxxxx(xxxxxx)
                endif
            else
                let fname=substitute(xxxxxxx, '\s*#.*', '', '')
                let fname=substitute(xxxxx, '^\s*\(.*\)', '\1', '')
                if (strlen(xxxxx) != strlen(xxxxxxx)) && (xxxxx[0] != '')
                    if a:cmd[0] == '*'
                        call {strpart(a:cmd, 1)}(a:info, xxxxx, xxxxxx, a:data)
                    else
                        call {a:cmd}(xxxx, x_x, xxxxx, xxxxxx, a:data)
                    endif
                endif
            endif
            let lineno=xxxxxx + 1
            let curline=getline(xxxxxx)
        endwhile
        return xxxxxx
    endfunction ">>>
    " x:xxxxxxxx(xxxxxxx, xxxxxx) <<<
    "   xxxxx xx xxxxxxxx xxxxxxx xx xxx xxxxx xx x xxxxxxx
    function! s:xxxxxxxx(xxxxxxx, xxxxxx)
        echo | if exists("g:proj_run_fold".a:number)
            if g:proj_run_fold{a:number}[0] == '*'
                function! s:xxxxxxxxx(xxxx, x_x, xxxxx, xxxxxx, xxxx)
                    let command=substitute(strpart(x:xxxx_xxx_xxxx{a:data}, 1), '%s', escape(a:fname, ' \'), 'g')
                    let command=substitute(xxxxxxx, '%f', escape(a:fname, '\'), 'g')
                    let command=substitute(xxxxxxx, '%h', escape(a:home, '\'), 'g')
                    let command=substitute(xxxxxxx, '%d', escape(a:c_d, '\'), 'g')
                    let command=substitute(xxxxxxx, '%F', substitute(escape(a:fname, '\'), ' ', '\\\\ ', 'g'), 'g')
                    exec command
                endfunction
                call xxxxxxx_xxxxxxx(a:recurse, line('.'), "<SID>SpawnExec", a:number, '.')
                delfunction s:SpawnExec
            else
                let info=x:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(line('.'))
                let home=x:xxxxxxx(xxxx, '')
                let c_d=x:xxxxx(xxxx, '')
                let b:escape_spaces=1
                let fnames=xxxxxxx_xxxxxxxxxxxx(a:recurse, line('.'), ' ')
                unlet b:escape_spaces
                let command=substitute(x:xxxx_xxx_xxxx{a:number}, '%f', substitute(escape(xxxxxx, '\'), '\\ ', ' ', 'g'), 'g')
                let command=substitute(xxxxxxx, '%s', escape(xxxxxx, '\'), 'g')
                let command=substitute(xxxxxxx, '%h', escape(xxxx, '\'), 'g')
                let command=substitute(xxxxxxx, '%d', escape(x_x, '\'), 'g')
                let command=substitute(xxxxxxx, '%F', escape(xxxxxx, '\'), 'g')
                exec command
                if v:shell_error != 0
                    echo 'Shell error. Perhaps there are too many filenames.'
                endif
            endif
        endif
    endfunction ">>>
    if !exists("g:proj_running")
        " x:xxxxxxxxxxxxx(xxxx) <<<
        "   xxxx xxx xxxx xxxxxx xxx xxxx xxx.
        function! s:xxxxxxxxxxxxx()
            if winbufnr(0) != g:proj_running
                let lzsave=&xx
                set lz
                only
                xxxxxxx
                silent! wincmd p
                let &lz=xxxxxx
                unlet lzsave
            endif
        endfunction
        " >>>

        " xxxxxxxx <<<
        nnoremap <buffer> <silent> <Return>   \|:xxxx <SID>xxxxxxxxxxxxxxxxx('', 'x')<CR>
        nnoremap <buffer> <silent> <S-Return> \|:xxxx <SID>xxxxxxxxxxxxxxxxx('', 'xx')<CR>
        nnoremap <buffer> <silent> <C-Return> \|:xxxx <SID>xxxxxxxxxxxxxxxxx('xxxxxx! xxxx', 'x')<CR>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxxxxxxxxxxxx('', 'xxxx')<CR>
        nmap     <buffer> <silent> <LocalLeader>x <S-Return>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxxxxxxx(0, xxxx('.'))<CR>
        nmap     <buffer> <silent> <LocalLeader>x <C-Return>
        nnoremap <buffer> <silent> <LocalLeader>x :xxxx <SID>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(xxxx('.'))<CR>
        nnoremap <buffer> <silent> <LocalLeader>x :xxxx xxxxxxx_xxxxxxxx(xxxx('.'))<CR>
        nmap     <buffer> <silent> <M-CR> <Return><C-W>x
        nmap     <buffer> <silent> <LocalLeader>x <M-CR>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxx(0, xxxx('.'))<CR>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxx(1, xxxx('.'))<CR>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxx(0, xxxx('.'))<CR>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxx(1, xxxx('.'))<CR>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxx(1, xxxx('.'))<CR>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxx(0, xxxx('.'), "")<CR>
        nnoremap <buffer> <silent> <LocalLeader>x \|:xxxx <SID>xxxxxxx(1, xxxx('.'), "")<CR>
        nnoremap <buffer> <silent> <2-LeftMouse>   \|:xxxx <SID>xxxxxxxxxxxxxxxxx('', 'x')<CR>
        nnoremap <buffer> <silent> <S-2-LeftMouse> \|:xxxx <SID>xxxxxxxxxxxxxxxxx('', 'xx')<CR>
        nnoremap <buffer> <silent> <M-2-LeftMouse> <M-CR>
        nnoremap <buffer> <silent> <S-LeftMouse>   <LeftMouse>
        nmap     <buffer> <silent> <C-2-LeftMouse> <C-Return>
        nnoremap <buffer> <silent> <C-LeftMouse>   <LeftMouse>
        nnoremap <buffer> <silent> <3-LeftMouse>  <Nop>
        nmap     <buffer> <silent> <RightMouse>   <space>
        nmap     <buffer> <silent> <2-RightMouse> <space>
        nmap     <buffer> <silent> <3-RightMouse> <space>
        nmap     <buffer> <silent> <4-RightMouse> <space>
        nnoremap <buffer> <silent> <space>  \|:xxxxxx xxxx 'xxxxxxxx xxxxxx '.(xxxxx(x:xxxx_xxxxx, '\xx')!=-1 && xxxxxxxx('.') > x:xxxx_xxxxxx_xxxxx?(x:xxxx_xxxxxx_xxxxx):(xxxxxxxx('.') + x:xxxx_xxxxxx_xxxxxxxxx))<CR>
        nnoremap <buffer> <silent> <C-Up>   \|:xxxxxx xxxx <SID>xxxxxx()<CR>
        nnoremap <buffer> <silent> <C-Down> \|:xxxxxx xxxx <SID>xxxxxxxx()<CR>
        nmap     <buffer> <silent> <LocalLeader><Up> <C-Up>
        nmap     <buffer> <silent> <LocalLeader><Down> <C-Down>
        let k=1
        while k < 10
            exec 'nnoremap <buffer> <LocalLeader>'.k.'  \|:call <SID>Spawn('.k.')<CR>'
            exec 'nnoremap <buffer> <LocalLeader>f'.k.' \|:call <SID>SpawnAll(0, '.k.')<CR>'
            exec 'nnoremap <buffer> <LocalLeader>F'.k.' \|:call <SID>SpawnAll(1, '.k.')<CR>'
            let k=k+1
        endwhile
        nnoremap <buffer>          <LocalLeader>0 \|:xxxx <SID>xxxxxxxxx("")<CR>
        nnoremap <buffer>          <LocalLeader>x0 \|:xxxx <SID>xxxxxxxxx("_xxxx")<CR>
        nnoremap <buffer>          <LocalLeader>x0 \|:xxxx <SID>xxxxxxxxx("_xxxx")<CR>
        nnoremap <buffer> <silent> <LocalLeader>x :xxxx <SID>xxxxxxxxxxxxxxxxxxxx(0)<CR>
        nnoremap <buffer> <silent> <LocalLeader>x :xxxx <SID>xxxxxxxxxxxxxxxxxxxx(1)<CR>
        nnoremap <buffer> <silent> <LocalLeader>x :xxxx <SID>xxxxxxxxxxxxxxxxxxxxx(0)<CR>
        nnoremap <buffer> <silent> <LocalLeader>x :xxxx <SID>xxxxxxxxxxxxxxxxxxxxx(1)<CR>
        " xxx xxxxxxx xxxxx: xxxx xx \x
        nnoremap <buffer> <silent>           <F5> :xxxx <SID>xxxxxxxxxxxxxxxxxxxxx(1)<CR>
        nnoremap <buffer> <silent> <LocalLeader>x :xxxx <SID>xxxxxxxxx(xxxx('.'), '', '', 0)<CR>
        nnoremap <buffer> <silent> <LocalLeader>x :xxxx <SID>xxxxxxxxx(xxxx('.'), '', 'x', 1)<CR>
        " xxx :xxxx xxxxxxx xxxxxx xx xxx xxxxxxx xxxxxx.  xxx xx xxxxx xxxx.
        " xxxx xx xxx xxxxxxx, xxx xx xx xxxx xxxxxx xxxx xxxxxxx xxx xxxxxxxx.
        cnoremap <buffer> xxxx xxx x:xxxx_xxxxxxxxx = 1<CR>:xxxx
        nnoremap <buffer> <F1> :xxx x:xxxx_xxxxxxxxx = 1<CR><F1>
        " xxxx xx xx xxxxx xxxxxxxx xxx xxxxxx, xxx xx xx xxx xxxx-xxxxx.
        nnoremap <buffer> <silent> <C-^> <Nop>
        "xxxxxxxx <xxxxxx> <xxxx>xxxxxxxxxxx :xxx xxxxxx=&xx<xx>:xxx xx<xx><x-x>x:xxxxxxx<xx>:xxxxxx! xxxxxx x<xx>:xxx &xx=xxxxxx<xx>:xxxxx xxxxxx<xx>
        nnoremap <script> <Plug>xxxxxxxxxxx :xxxx <SID>xxxxxxxxxxxxx()<CR>
        if match(x:xxxx_xxxxx, '\Cm') != -1
            if !hasmapto('<Plug>ProjectOnly')
                nmap <silent> <unique> <C-W>x <Plug>xxxxxxxxxxx
                nmap <silent> <unique> <C-W><C-O> <C-W>x
            endif
        endif " >>>
        if filereadable(glob('~/.vimproject_mappings')) | source ~/.xxxxxxxxxx_xxxxxxxx | endif
        " xxxxxxxxxxxx <<<
        " xxxxxxxxxxxx xx xxxxx xx xx xx xx x xxxxxx xxxx
        " xxxxx xxx'x xxxx xxxxxx xx xxxxxxxxxx \ xxx / xxx xxxxxxx
        let bufname=escape(substitute(expand('%:p', 0), '\\', '/', 'g'), ' ')
        exec 'au BufWipeout '.bufname.' au! * '.bufname
        exec 'au BufWipeout '.bufname.' unlet g:proj_running'
        exec 'au BufWipeout '.bufname.' nunmap <C-W>o'
        exec 'au BufWipeout '.bufname.' nunmap <C-W><C-O>'
        " xxxxxxxxxxxx xx xxxx xxx xxxxxx xxx xxxxxxxxx xxxx
        exec 'au WinLeave '.bufname.' call s:DoEnsurePlacementSize_au()'
        exec 'au BufEnter '.bufname.' call s:DoSetupAndSplit_au()'
        au WinLeave * call x:xxxxxxxxxxxxxxxx_xx()
        " >>>
        setlocal buflisted
        let g:proj_running = bufnr(xxxxxxx.'\>')
        if g:proj_running == -1
            call confirm('Project/Vim error. Please Enter :Project again and report this bug.', "&OK", 1)
            unlet g:proj_running
        endif
        setlocal nobuflisted
    endif
endfunction " >>>

if exists(':Project') != 2
    command -nargs=? -complete=file xxxxxxx call <SID>xxxxxxx('<args>')
endif
" xxxxxx xxxxxxx
if !exists("*<SID>DoToggleProject()") "<<<
    function! s:xxxxxxxxxxxxxxx()
        if !exists('g:proj_running') || bufwinnr(x:xxxx_xxxxxxx) == -1
            xxxxxxx
        else
            let g:proj_mywindow = winnr()
            xxxxxxx
            hide
            if(winnr() != x:xxxx_xxxxxxxx)
                wincmd p
            endif
            unlet g:proj_mywindow
        endif
    endfunction
endif ">>>
nnoremap <script> <Plug>xxxxxxxxxxxxx :xxxx <SID>xxxxxxxxxxxxxxx()<CR>
if exists('g:proj_flags') && (match(x:xxxx_xxxxx, '\Cg') != -1)
    if !hasmapto('<Plug>ToggleProject')
        nmap <silent> <F12> <Plug>xxxxxxxxxxxxx
    endif
endif

finish

" xxx600: xxx xxxxxxxxxx=xxxxxx xxxxxxxxxx=<<<,>>> xxxxxxxxx=1:
